# Overview 

This example demonstrates the creation and use of a Legend service execution library.

# Service Execution Primer 

A "service execution" jar is a Java library generated from a Legend model.

Consider the service model below. It is a grouping of a data access query with a mapping to 
a physical (relational store) and specific database connection.
```
Service service::persons
{
  pattern: '/api/persons';
  documentation: '';
  autoActivateUpdates: true;
  execution: Single
  {
    query: |domain::Person.all()->project([x|$x.name, x|$x.firmId], ['Name', 'FirmId']);
    mapping: mapping::firmperson;
    runtime: runtime::firmperson;
  }
}
```
Once modeled in Legend, the Legend project's SDLC infrastucture consumes this model and generates a Java class.

```
personsService service = new personsService();
``` 

When executed, this class connects to the database specified in the model, queries and returns the data.

# Building a Service Execution Jar 

In the simplest case, a service execution jar is autogenerated by the Legend project's SDLC. 

To generate a service execution jar using Legend SDLC

* Create a Legend Studio project https://legend.finos.org/studio. 
* Use Legend Studio to create a Legend model. This model should include a service definition as shown above
* Use Legend Studio SDLC controls and/or native Gitlab controls to merge your model to the master branch
* Once merged, the Gitlab pipeline configured by Legend SDLC, runs various code generation plugins which generate a service execution jar.

As a concrete example 
* Legend Studio Project https://legend.finos.org/studio/-/view/UAT-29500652
* Legend Studio Project Pipeline https://gitlab.com/finosfoundation/legend/showcase/legend-showcase-project2/-/pipelines 
* Legend SDLC Generated Artifacts https://gitlab.com/finosfoundation/legend/showcase/legend-showcase-project2/-/packages 

# Using a Service Execution Jar 

Once a jar has been created it can be consumed like any other jar in a Java application.

See 

